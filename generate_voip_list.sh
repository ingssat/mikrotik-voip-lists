#!/usr/bin/env bash
set -euo pipefail

OUT="voip_videocall.rsc"
TMPDIR="$(mktemp -d)"
LOG="$TMPDIR/generator.log"

# cleanup on exit
trap 'rm -rf "$TMPDIR"' EXIT

echo "# Autogenerated on $(date -u)" > "$OUT"
echo "/ip firewall address-list" >> "$OUT"

log() { echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG"; }

# Validate IPv4/CIDR and normalize
# Accepts input like 1.2.3.4 or 1.2.3.0/24
validate_ipv4_cidr() {
  local ip="$1"
  # Extract ip and optional prefix
  if [[ "$ip" =~ ^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})(\/([0-9]{1,2}))?$ ]]; then
    local addr="${BASH_REMATCH[1]}"
    local prefix="${BASH_REMATCH[3]:-}"
    # validate each octet <=255
    IFS='.' read -r o1 o2 o3 o4 <<< "$addr"
    for o in $o1 $o2 $o3 $o4; do
      if (( o < 0 || o > 255 )); then
        return 1
      fi
    done
    # validate prefix if present
    if [[ -n "$prefix" ]]; then
      if (( prefix < 0 || prefix > 32 )); then
        return 1
      fi
    else
      # if no prefix, assume /32
      prefix=32
    fi
    # print normalized cidr
    printf '%s/%s' "$addr" "$prefix"
    return 0
  fi
  return 1
}

# Try parse JSON using jq, fallback to regex parsing
fetch_and_extract_cidrs() {
  local url="$1"
  local tag="$2"
  local tmp="$TMPDIR/$(basename "$tag" | tr '/: ' '_').download"
  log "-> Fetching $tag from $url"
  if ! curl -sfL --max-time 30 "$url" -o "$tmp"; then
    log "!! Failed to download $url"
    return 1
  fi

  # detect if it's JSON
  if jq -e . "$tmp" >/dev/null 2>&1; then
    log "   (source is JSON, using jq)"
    # Try common keys: ipv4Prefix, prefix, cidr, ipv4Prefix in google json, ips array in MS endpoints
    # Collect possible fields
    jq -r '
      (.. | objects | .ipv4Prefix? // empty),
      (.. | objects | .ipv4Prefix? // empty),
      (.. | objects | .ipv4Prefix? // empty),
      (.. | objects | .prefix? // empty),
      (.. | objects | .cidr? // empty),
      (.. | objects | .ipv4Prefix? // empty),
      (.. | objects | .prefixes[]?.ipv4Prefix? // empty),
      (.. | objects | .prefixes[]?.ipv4Prefix? // empty),
      (.. | arrays | .[]? | select(type=="string"))
    ' "$tmp" 2>/dev/null | \
      grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}(\/[0-9]{1,2})?' | \
      sort -u > "$tmp.cidr"
  else
    log "   (source is plain text/HTML)"
    # Extract IPv4 and CIDR-like tokens
    grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}(\/[0-9]{1,2})?' "$tmp" | sort -u > "$tmp.cidr"
  fi

  # Validate and write to OUT
  local count=0
  while read -r token; do
    [[ -z "$token" ]] && continue
    if cidr=$(validate_ipv4_cidr "$token"); then
      echo "add list=voip_videocall address=$cidr comment=\"$tag\"" >> "$OUT"
      ((count++))
    fi
  done < "$tmp.cidr"

  log "   -> $count valid CIDRs added for $tag"
  return 0
}
# Requiere: curl, jq, grep, sort
fetch_and_extract() {
  local url="$1"
  local tag="$2"
  local tmp="$TMPDIR/$(echo "$tag" | tr '/: ' '_').dl"
  log "--> Descargando $tag desde $url"
  if ! curl -sfL --connect-timeout 12 "$url" -o "$tmp"; then
    log "!! Error descargando $url"
    return 1
  fi

  # si es JSON válido: extraer todos los valores escalares y buscar CIDRs
  if jq -e . "$tmp" >/dev/null 2>&1; then
    log "   (JSON detectado; extrayendo valores escalares con jq)"
    jq -r '.. | scalars | tostring' "$tmp" \
      | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}(\/[0-9]{1,2})?' \
      | sort -u > "$tmp.cidr"
  else
    log "   (Texto plano detectado; buscando CIDRs con grep)"
    grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}(\/[0-9]{1,2})?' "$tmp" | sort -u > "$tmp.cidr"
  fi

  local added=0
  while read -r token; do
    [[ -z "$token" ]] && continue
    if cidr=$(validate_ipv4_cidr "$token"); then
      echo "add list=voip_videocall address=$cidr comment=\"$tag\"" >> "$OUT"
      ((added++))
    fi
  done < "$tmp.cidr"

  log "   -> $added CIDR(s) válidos añadidos para $tag"
  return 0
}

# Wrapper that tolerates failures (so the whole generation doesn't die)
maybe_fetch() {
  local url="$1"; shift
  local tag="$1"; shift
  if ! fetch_and_extract "$url" "$tag"; then
    log "!! warning: no CIDRs added from $tag ($url)"
  fi
}

# ========== SOURCES ==========

# Zoom (official TXT)
maybe_fetch "https://zoomcdn.zoom.us/ips/ZoomIPRanges.txt" "Zoom-primary"
maybe_fetch "https://assets.zoom.us/docs/ipranges/ZoomMeetings.txt" "Zoom-alt"
# Google (gstatic) - JSON, we will extract ipv4Prefix fields
maybe_fetch "https://www.gstatic.com/ipranges/goog.json" "Google"

# Microsoft Office 365 / Teams endpoints (worldwide)
maybe_fetch "https://endpoints.office.com/endpoints/worldwide?clientrequestid=$(uuidgen)" "Office365/Teams"

# WhatsApp / Meta (JSON)
maybe_fetch "https://ip-ranges.meta.com/metadata.json" "Meta/WhatsApp"


# GoTo: aws media list (public JSON)
maybe_fetch "https://builds.cdn.getgo.com/selectedAWSIPs/selectedAWSIPs.json" "GoTo-AWS-media"

# GoTo own published minimal firewall/ranges -- add as manual fixed ranges (complement)
# These are stable-ish ranges published by GoTo in their docs (keeps common media ranges)
cat >> "$OUT" <<'EOF'
# Manual GoTo fixed ranges (from vendor docs)
add list=voip_videocall address=68.64.0.0/19 comment="GoTo-manual"
add list=voip_videocall address=173.199.0.0/18 comment="GoTo-manual"
add list=voip_videocall address=23.239.224.0/19 comment="GoTo-manual"
add list=voip_videocall address=202.173.24.0/21 comment="GoTo-manual"
EOF

# Jitsi / 8x8: there's no single official JSON endpoint; use a public PDF as a source (not ideal)
# We will attempt to fetch a plain-text mirror if available; otherwise add well-known ranges manually.
maybe_fetch "https://help.evenito.com/hubfs/ip-ranges.pdf" "Jitsi-pdf" || true

# Manual Jitsi/8x8 ranges (extracted from public docs)
cat >> "$OUT" <<'EOF'
# Manual Jitsi/8x8 ranges (from public docs)
add list=voip_videocall address=3.219.176.32/27 comment="Jitsi-manual"
add list=voip_videocall address=3.235.61.96/27 comment="Jitsi-manual"
add list=voip_videocall address=193.122.184.0/24 comment="Jitsi-manual"
add list=voip_videocall address=34.223.80.128/27 comment="Jitsi-manual"
add list=voip_videocall address=44.234.37.64/27 comment="Jitsi-manual"
EOF

# Zoom / Microsoft etc already done above. Add other public lists only if they exist:
# Example placeholders for other public txt/json lists you trust (edit/add real URLs if you have)
# maybe_fetch "https://example.com/bluejeans.txt" "BlueJeans"
# maybe_fetch "https://example.com/discord.json" "Discord"

log "Generation finished. Output saved to $OUT"
log "Log file: $LOG"

# Print summary counts
echo
echo "Summary (first 30 entries):"
sed -n '1,30p' "$OUT"
echo
wc -l "$OUT" | sed 's/^/Total lines: /'
